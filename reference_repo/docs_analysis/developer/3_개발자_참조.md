# Unity Perception ê°œë°œì ì°¸ì¡°

Labeler, Randomizer ê°œë°œ ê°€ì´ë“œ ë° ì½”ë“œ ì˜ˆì œ

---

## ğŸ“– ì´ ë¬¸ì„œëŠ”?

**ì½ê¸° ì‹œê°„**: 1-2ì‹œê°„
**ëŒ€ìƒ**: Unity ê°œë°œì (C#)
**ì „ì œ ì¡°ê±´**:
- [1_ë¹ ë¥¸ì‹œì‘.md](1_ë¹ ë¥¸ì‹œì‘.md) ì½ê¸° ì™„ë£Œ
- [2_ì•„í‚¤í…ì²˜_ê°œìš”.md](2_ì•„í‚¤í…ì²˜_ê°œìš”.md) ì½ê¸° ì™„ë£Œ

**ëª©ì **:
- Labeler ê°œë°œ ê°€ì´ë“œ (ì½”ë“œ ì˜ˆì œ í¬í•¨)
- Randomizer ê°œë°œ ê°€ì´ë“œ (ì½”ë“œ ì˜ˆì œ í¬í•¨)
- í•µì‹¬ íŒŒì¼ ìœ„ì¹˜ ë° ì°¸ì¡°
- ê°œë°œ íŒ¨í„´ ë° Best Practice

---

## ğŸ—ï¸ ê°œë°œ í™˜ê²½ ì„¤ì •

### 1. Unity Perception íŒ¨í‚¤ì§€ ìœ„ì¹˜

```
/home/jinhyuk2me/test_ws/lk_sdg/reference_repo/com.unity.perception/
```

### 2. í•µì‹¬ ë””ë ‰í† ë¦¬ êµ¬ì¡°

```
com.unity.perception/
â”œâ”€â”€ Runtime/
â”‚   â”œâ”€â”€ GroundTruth/              # Camera & Labeler
â”‚   â”‚   â”œâ”€â”€ PerceptionCamera.cs
â”‚   â”‚   â”œâ”€â”€ DatasetCapture.cs
â”‚   â”‚   â”œâ”€â”€ Labelers/
â”‚   â”‚   â”‚   â”œâ”€â”€ CameraLabeler.cs  # ê¸°ë³¸ í´ë˜ìŠ¤
â”‚   â”‚   â”‚   â”œâ”€â”€ BoundingBox/      # bbox ì˜ˆì œ
â”‚   â”‚   â”‚   â”œâ”€â”€ SemanticSegmentation/
â”‚   â”‚   â”‚   â””â”€â”€ ...
â”‚   â”‚   â”œâ”€â”€ Sensors/
â”‚   â”‚   â””â”€â”€ Consumers/            # ì¶œë ¥ ì‹œìŠ¤í…œ
â”‚   â”‚
â”‚   â””â”€â”€ Randomization/            # Randomizer
â”‚       â”œâ”€â”€ Scenarios/
â”‚       â”œâ”€â”€ Randomizers/
â”‚       â”‚   â””â”€â”€ Randomizer.cs     # ê¸°ë³¸ í´ë˜ìŠ¤
â”‚       â”œâ”€â”€ Parameters/
â”‚       â”œâ”€â”€ Samplers/
â”‚       â””â”€â”€ RandomizerLibrary/    # 9ê°œ ê¸°ë³¸ ì œê³µ
```

---

## ğŸ“¦ Section 1: Labeler ê°œë°œ ê°€ì´ë“œ

### 1.1 CameraLabeler ê¸°ë³¸ êµ¬ì¡°

**íŒŒì¼ ìœ„ì¹˜**: `Runtime/GroundTruth/Labelers/CameraLabeler.cs`

```csharp
using UnityEngine;
using UnityEngine.Perception.GroundTruth;

public abstract class CameraLabeler : MonoBehaviour
{
    // í•„ìˆ˜ êµ¬í˜„: Labeler ì„¤ëª…
    public abstract string description { get; }

    // í•„ìˆ˜ êµ¬í˜„: Labeler ID (ê³ ìœ  ì‹ë³„ì)
    public abstract string labelerId { get; }

    // ì‹œê°í™” ì§€ì› ì—¬ë¶€
    protected abstract bool supportsVisualization { get; }

    // Sensor í•¸ë“¤ (Annotation ë³´ê³ ìš©)
    protected SensorHandle sensorHandle { get; private set; }

    // ìƒëª…ì£¼ê¸° ë©”ì„œë“œ
    protected virtual void Setup() { }
    protected virtual void OnUpdate() { }
    protected virtual void OnBeginRendering(ScriptableRenderContext ctx) { }
    protected virtual void OnEndRendering(ScriptableRenderContext ctx) { }
    protected virtual void Cleanup() { }
}
```

---

### 1.2 ê°„ë‹¨í•œ Labeler ì˜ˆì œ: ObjectCountLabeler

**ëª©ì **: ì”¬ì˜ Person ê°œìˆ˜ ì„¸ê¸°

```csharp
using UnityEngine;
using UnityEngine.Perception.GroundTruth;

public class PersonCountLabeler : CameraLabeler
{
    // Labeler ì •ë³´
    public override string description => "Counts persons in view";
    public override string labelerId => "person-count";
    protected override bool supportsVisualization => false;

    // Annotation Definition
    MetricDefinition m_MetricDefinition;

    // Setup: ì´ˆê¸°í™”
    protected override void Setup()
    {
        // Metric ì •ì˜ ë“±ë¡
        m_MetricDefinition = DatasetCapture.RegisterMetricDefinition(
            "person-count",
            "Number of persons visible",
            Guid.NewGuid()
        );
    }

    // OnUpdate: ë§¤ í”„ë ˆì„ ì‹¤í–‰
    protected override void OnUpdate()
    {
        // Person íƒœê·¸ ë‹¬ë¦° GameObject ì°¾ê¸°
        var persons = GameObject.FindGameObjectsWithTag("Person");
        int count = persons.Length;

        // Metric ë³´ê³ 
        sensorHandle.ReportMetric(m_MetricDefinition, new[] {
            new { count = count }
        });
    }
}
```

**ì‚¬ìš©ë²•**:
1. PerceptionCamera GameObjectì— `PersonCountLabeler` ì»´í¬ë„ŒíŠ¸ ì¶”ê°€
2. Person GameObjectì— "Person" íƒœê·¸ ë¶™ì´ê¸°
3. Play ì‹œ ìë™ìœ¼ë¡œ ë§¤ í”„ë ˆì„ ê°œìˆ˜ ì¹´ìš´íŠ¸

---

### 1.3 BoundingBox2DLabeler ìƒì† ì˜ˆì œ

**ëª©ì **: Personë§Œ Bounding Box ìƒì„±

**ì°¸ì¡° íŒŒì¼**: `Runtime/GroundTruth/Labelers/BoundingBox/BoundingBoxLabeler.cs`

```csharp
using UnityEngine;
using UnityEngine.Perception.GroundTruth;
using UnityEngine.Perception.GroundTruth.Labelers;

public class PersonDetectionLabeler : BoundingBox2DLabeler
{
    public override string description => "2D bounding boxes for persons only";
    public override string labelerId => "person-detection-bbox";

    // IdLabelConfig: Person ë¼ë²¨ë§Œ í¬í•¨
    public IdLabelConfig personLabelConfig;

    protected override void Setup()
    {
        // BoundingBox2DLabelerì˜ Setup í˜¸ì¶œ
        base.Setup();

        // Person ë¼ë²¨ë§Œ í•„í„°ë§
        if (personLabelConfig == null)
        {
            Debug.LogError("PersonLabelConfig is not assigned!");
        }
    }

    protected override void OnUpdate()
    {
        // ë¶€ëª¨ í´ë˜ìŠ¤ì˜ bbox ìƒì„± ë¡œì§ ì‹¤í–‰
        base.OnUpdate();
    }
}
```

**IdLabelConfig ì„¤ì •**:
1. Project ì°½ì—ì„œ `Create > Perception > Id Label Config`
2. "PersonLabelConfig" ìƒì„±
3. Label ì¶”ê°€: "person" (ID: 1)
4. PersonDetectionLabelerì˜ `personLabelConfig` í•„ë“œì— í• ë‹¹

---

### 1.4 Custom Annotation Labeler: TrackingLabeler

**ëª©ì **: Personì— Global ID í• ë‹¹ ë° ì¶”ì 

```csharp
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Perception.GroundTruth;

public class TrackingLabeler : CameraLabeler
{
    public override string description => "Assigns global IDs to persons";
    public override string labelerId => "person-tracking";
    protected override bool supportsVisualization => false;

    // Annotation Definition
    AnnotationDefinition m_AnnotationDefinition;

    // Global ID ê´€ë¦¬
    Dictionary<GameObject, int> m_PersonToId = new Dictionary<GameObject, int>();
    int m_NextId = 0;

    protected override void Setup()
    {
        // Annotation ì •ì˜ ë“±ë¡
        m_AnnotationDefinition = DatasetCapture.RegisterAnnotationDefinition(
            "person-tracking",
            "Global person IDs",
            "Persistent ID across frames",
            id: Guid.NewGuid()
        );
    }

    protected override void OnUpdate()
    {
        // Person íƒœê·¸ ë‹¬ë¦° GameObject ì°¾ê¸°
        var persons = GameObject.FindGameObjectsWithTag("Person");

        var annotations = new List<TrackingAnnotation>();

        foreach (var person in persons)
        {
            // ê¸°ì¡´ IDê°€ ì—†ìœ¼ë©´ ìƒˆë¡œ í• ë‹¹
            if (!m_PersonToId.ContainsKey(person))
            {
                m_PersonToId[person] = m_NextId++;
            }

            int globalId = m_PersonToId[person];

            // Bounding Box ê³„ì‚° (ê°„ë‹¨í•œ ì˜ˆì‹œ)
            Bounds bounds = CalculateBounds(person);

            annotations.Add(new TrackingAnnotation
            {
                globalId = globalId,
                instanceId = person.GetInstanceID(),
                bbox = new BBox2D
                {
                    x = bounds.min.x,
                    y = bounds.min.y,
                    width = bounds.size.x,
                    height = bounds.size.y
                }
            });
        }

        // Annotation ë³´ê³ 
        sensorHandle.ReportAnnotation(m_AnnotationDefinition, annotations.ToArray());
    }

    Bounds CalculateBounds(GameObject obj)
    {
        // Renderer ê¸°ë°˜ bounds ê³„ì‚°
        var renderer = obj.GetComponent<Renderer>();
        if (renderer != null)
            return renderer.bounds;

        return new Bounds(obj.transform.position, Vector3.one);
    }

    // Annotation ë°ì´í„° êµ¬ì¡°
    [System.Serializable]
    public struct TrackingAnnotation
    {
        public int globalId;
        public int instanceId;
        public BBox2D bbox;
    }

    [System.Serializable]
    public struct BBox2D
    {
        public float x;
        public float y;
        public float width;
        public float height;
    }
}
```

**JSON ì¶œë ¥ ì˜ˆì‹œ**:
```json
{
  "annotations": [
    {
      "id": "person-tracking",
      "values": [
        {
          "globalId": 0,
          "instanceId": 12345,
          "bbox": {"x": 100, "y": 200, "width": 50, "height": 120}
        },
        {
          "globalId": 1,
          "instanceId": 12346,
          "bbox": {"x": 300, "y": 180, "width": 55, "height": 130}
        }
      ]
    }
  ]
}
```

---

### 1.5 AsyncFuture íŒ¨í„´ (Phase 2 ëª©í‘œ)

**ëª©ì **: GPU ì‘ì—… ì™„ë£Œ ëŒ€ê¸° (ë¹„ë™ê¸°)

**ì°¸ì¡° íŒŒì¼**: `Runtime/GroundTruth/Labelers/SemanticSegmentation/SemanticSegmentationLabeler.cs`

```csharp
using UnityEngine;
using UnityEngine.Perception.GroundTruth;
using UnityEngine.Rendering;

public class AsyncSegmentationLabeler : CameraLabeler
{
    public override string description => "Async segmentation";
    public override string labelerId => "async-segmentation";
    protected override bool supportsVisualization => false;

    RenderTexture m_SegmentationTexture;
    AnnotationDefinition m_AnnotationDefinition;

    protected override void Setup()
    {
        // RenderTexture ìƒì„±
        m_SegmentationTexture = new RenderTexture(1920, 1080, 0, RenderTextureFormat.ARGB32);

        m_AnnotationDefinition = DatasetCapture.RegisterAnnotationDefinition(
            "segmentation",
            "Semantic segmentation",
            "Per-pixel class labels",
            id: Guid.NewGuid()
        );
    }

    protected override void OnEndRendering(ScriptableRenderContext ctx)
    {
        // GPUì— ë Œë”ë§ ìš”ì²­ (ë¹„ë™ê¸°)
        var future = AsyncGPUReadback.Request(m_SegmentationTexture);

        // AsyncFutureë¡œ Annotation ë³´ê³ 
        sensorHandle.ReportAnnotationAsync(m_AnnotationDefinition, future.ContinueWith(data =>
        {
            // GPU ì‘ì—… ì™„ë£Œ í›„ ì‹¤í–‰
            byte[] pixels = data.GetData<byte>().ToArray();

            return new SegmentationAnnotation
            {
                imageFile = "segmentation.png",
                width = 1920,
                height = 1080,
                data = pixels
            };
        }));
    }

    [System.Serializable]
    public struct SegmentationAnnotation
    {
        public string imageFile;
        public int width;
        public int height;
        public byte[] data;
    }
}
```

**ì¥ì **:
- GPU â†’ CPU ì „ì†¡ ë™ì•ˆ ë‹¤ë¥¸ ì‘ì—… ê°€ëŠ¥
- 15 FPS ëª©í‘œ ë‹¬ì„± (Phase 2)

---

## ğŸ² Section 2: Randomizer ê°œë°œ ê°€ì´ë“œ

### 2.1 Randomizer ê¸°ë³¸ êµ¬ì¡°

**íŒŒì¼ ìœ„ì¹˜**: `Runtime/Randomization/Randomizers/Randomizer.cs`

```csharp
using UnityEngine;
using UnityEngine.Perception.Randomization.Randomizers;

public abstract class Randomizer : MonoBehaviour
{
    // Scenario (ë¶€ëª¨)
    public ScenarioBase scenario { get; private set; }

    // TagManager (GameObject ì¿¼ë¦¬ìš©)
    protected RandomizerTagManager tagManager => scenario.tagManager;

    // ìƒëª…ì£¼ê¸° ë©”ì„œë“œ
    protected virtual void OnCreate() { }
    protected virtual void OnEnable() { }
    protected virtual void OnDisable() { }
    protected virtual void OnIterationStart() { }
    protected virtual void OnIterationEnd() { }
    protected virtual void OnUpdate() { }
}
```

---

### 2.2 ê°„ë‹¨í•œ Randomizer ì˜ˆì œ: LightRandomizer

**ëª©ì **: ì¡°ëª… ë°ê¸° ëœë¤í™”

**ì°¸ì¡° íŒŒì¼**: `Runtime/Randomization/RandomizerLibrary/LightRandomizer.cs`

```csharp
using UnityEngine;
using UnityEngine.Perception.Randomization.Randomizers;
using UnityEngine.Perception.Randomization.Parameters;

[AddComponentMenu("Perception/Randomizers/Light Randomizer")]
public class LightRandomizer : Randomizer
{
    // Parameter: ì¡°ëª… ë°ê¸° ë²”ìœ„
    public FloatParameter lightIntensity = new FloatParameter
    {
        value = new UniformSampler(0.5f, 2.0f) // 0.5 ~ 2.0 ê· ë“± ë¶„í¬
    };

    // Parameter: ì¡°ëª… ìƒ‰ìƒ
    public ColorHsvaParameter lightColor = new ColorHsvaParameter();

    protected override void OnIterationStart()
    {
        // LightTag ë‹¬ë¦° ëª¨ë“  Light GameObject ì°¾ê¸°
        var lights = tagManager.Query<LightRandomizerTag>();

        foreach (var lightTag in lights)
        {
            Light light = lightTag.GetComponent<Light>();
            if (light == null) continue;

            // ëœë¤ ë°ê¸° ì ìš©
            light.intensity = lightIntensity.Sample();

            // ëœë¤ ìƒ‰ìƒ ì ìš©
            light.color = lightColor.Sample();
        }
    }
}

// Tag ì •ì˜
public class LightRandomizerTag : RandomizerTag { }
```

**ì‚¬ìš©ë²•**:
1. Scenario GameObject ìƒì„±
2. `LightRandomizer` ì»´í¬ë„ŒíŠ¸ ì¶”ê°€
3. Light GameObjectì— `LightRandomizerTag` ì»´í¬ë„ŒíŠ¸ ì¶”ê°€
4. Play ì‹œ ë§¤ Iterationë§ˆë‹¤ ì¡°ëª… ë³€í™”

---

### 2.3 CCTV Noise Randomizer (Phase 2)

**ëª©ì **: Gaussian ë…¸ì´ì¦ˆ, Salt & Pepper ë…¸ì´ì¦ˆ ì¶”ê°€

```csharp
using UnityEngine;
using UnityEngine.Rendering;
using UnityEngine.Rendering.Universal;
using UnityEngine.Perception.Randomization.Randomizers;
using UnityEngine.Perception.Randomization.Parameters;

[AddComponentMenu("Perception/Randomizers/CCTV Noise Randomizer")]
public class CCTVNoiseRandomizer : Randomizer
{
    // Parameter: Gaussian ë…¸ì´ì¦ˆ ê°•ë„
    public FloatParameter gaussianNoise = new FloatParameter
    {
        value = new UniformSampler(0.0f, 0.05f) // 0 ~ 5%
    };

    // Parameter: Salt & Pepper í™•ë¥ 
    public FloatParameter saltPepperProbability = new FloatParameter
    {
        value = new UniformSampler(0.0f, 0.01f) // 0 ~ 1%
    };

    // Volume (Post-processing)
    Volume m_PostProcessVolume;

    protected override void OnCreate()
    {
        // Volume ì°¾ê¸° ë˜ëŠ” ìƒì„±
        m_PostProcessVolume = FindObjectOfType<Volume>();
        if (m_PostProcessVolume == null)
        {
            GameObject volumeGo = new GameObject("Post-process Volume");
            m_PostProcessVolume = volumeGo.AddComponent<Volume>();
            m_PostProcessVolume.isGlobal = true;
        }
    }

    protected override void OnIterationStart()
    {
        // Gaussian ë…¸ì´ì¦ˆ ê°•ë„ ìƒ˜í”Œë§
        float gaussianStrength = gaussianNoise.Sample();

        // Salt & Pepper í™•ë¥  ìƒ˜í”Œë§
        float saltPepperProb = saltPepperProbability.Sample();

        // Custom Post-processing íš¨ê³¼ ì ìš©
        ApplyNoiseEffect(gaussianStrength, saltPepperProb);
    }

    void ApplyNoiseEffect(float gaussian, float saltPepper)
    {
        // ì‹¤ì œ êµ¬í˜„ì€ Custom Post-processing íš¨ê³¼ í•„ìš”
        // ì—¬ê¸°ì„œëŠ” Film Grainìœ¼ë¡œ ëŒ€ì²´ (ê°„ë‹¨í•œ ì˜ˆì‹œ)
        if (m_PostProcessVolume.profile.TryGet<FilmGrain>(out var filmGrain))
        {
            filmGrain.intensity.value = gaussian;
        }
    }
}
```

---

### 2.4 Crowd Behavior Randomizer (Phase 2)

**ëª©ì **: Personì˜ í–‰ë™ ëœë¤í™” (Idle, Walk, Run)

```csharp
using UnityEngine;
using UnityEngine.Perception.Randomization.Randomizers;
using UnityEngine.Perception.Randomization.Parameters;

[AddComponentMenu("Perception/Randomizers/Crowd Behavior Randomizer")]
public class CrowdBehaviorRandomizer : Randomizer
{
    // Parameter: í–‰ë™ ì¢…ë¥˜
    public CategoricalParameter<string> behavior = new CategoricalParameter<string>
    {
        probabilities = new[]
        {
            new { option = "Idle", probability = 0.3f },
            new { option = "Walk", probability = 0.5f },
            new { option = "Run", probability = 0.2f }
        }
    };

    // Parameter: ì´ë™ ì†ë„
    public FloatParameter walkSpeed = new FloatParameter
    {
        value = new NormalSampler(1.4f, 0.3f, 0.5f, 2.5f) // í‰ê·  1.4 m/s, í‘œì¤€í¸ì°¨ 0.3
    };

    protected override void OnIterationStart()
    {
        // PersonTag ë‹¬ë¦° ëª¨ë“  GameObject ì°¾ê¸°
        var persons = tagManager.Query<PersonTag>();

        foreach (var personTag in persons)
        {
            // í–‰ë™ ìƒ˜í”Œë§
            string action = behavior.Sample();

            // Animator ì»´í¬ë„ŒíŠ¸ ê°€ì ¸ì˜¤ê¸°
            Animator animator = personTag.GetComponent<Animator>();
            if (animator == null) continue;

            // í–‰ë™ì— ë”°ë¼ Animation State ë³€ê²½
            switch (action)
            {
                case "Idle":
                    animator.SetBool("isWalking", false);
                    animator.SetBool("isRunning", false);
                    break;

                case "Walk":
                    animator.SetBool("isWalking", true);
                    animator.SetBool("isRunning", false);
                    // ì´ë™ ì†ë„ ì„¤ì •
                    personTag.GetComponent<NavMeshAgent>().speed = walkSpeed.Sample();
                    break;

                case "Run":
                    animator.SetBool("isWalking", false);
                    animator.SetBool("isRunning", true);
                    personTag.GetComponent<NavMeshAgent>().speed = walkSpeed.Sample() * 2.0f;
                    break;
            }
        }
    }
}

// Tag ì •ì˜
public class PersonTag : RandomizerTag { }
```

---

### 2.5 Crowd Density Randomizer (Phase 2)

**ëª©ì **: êµ°ì¤‘ ë°€ë„ ì¡°ì ˆ (Person GameObject ìƒì„±/ì‚­ì œ)

```csharp
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.AI;
using UnityEngine.Perception.Randomization.Randomizers;
using UnityEngine.Perception.Randomization.Parameters;

[AddComponentMenu("Perception/Randomizers/Crowd Density Randomizer")]
public class CrowdDensityRandomizer : Randomizer
{
    // Parameter: Person ê°œìˆ˜
    public IntParameter personCount = new IntParameter
    {
        value = new UniformSampler(10, 50) // 10 ~ 50ëª…
    };

    // Person Prefab
    public GameObject personPrefab;

    // ìƒì„±ëœ Person ëª©ë¡
    List<GameObject> m_SpawnedPersons = new List<GameObject>();

    protected override void OnIterationStart()
    {
        int targetCount = personCount.Sample();

        // í˜„ì¬ Person ê°œìˆ˜
        int currentCount = m_SpawnedPersons.Count;

        if (currentCount < targetCount)
        {
            // Person ì¶”ê°€ ìƒì„±
            int toSpawn = targetCount - currentCount;
            for (int i = 0; i < toSpawn; i++)
            {
                SpawnPerson();
            }
        }
        else if (currentCount > targetCount)
        {
            // Person ì‚­ì œ
            int toRemove = currentCount - targetCount;
            for (int i = 0; i < toRemove; i++)
            {
                RemovePerson();
            }
        }
    }

    void SpawnPerson()
    {
        // NavMesh ìœ„ì˜ ëœë¤ ìœ„ì¹˜ ì°¾ê¸°
        Vector3 randomPos = GetRandomNavMeshPosition();

        // Person ìƒì„±
        GameObject person = Instantiate(personPrefab, randomPos, Quaternion.identity);

        // PersonTag ì¶”ê°€ (ë™ì ìœ¼ë¡œ TagManagerì— ë“±ë¡ë¨)
        person.AddComponent<PersonTag>();

        m_SpawnedPersons.Add(person);
    }

    void RemovePerson()
    {
        if (m_SpawnedPersons.Count == 0) return;

        // ë§ˆì§€ë§‰ Person ì‚­ì œ
        GameObject person = m_SpawnedPersons[m_SpawnedPersons.Count - 1];
        m_SpawnedPersons.RemoveAt(m_SpawnedPersons.Count - 1);

        Destroy(person);
    }

    Vector3 GetRandomNavMeshPosition()
    {
        // ê°„ë‹¨í•œ ì˜ˆì‹œ: ì› ì•ˆì˜ ëœë¤ ìœ„ì¹˜
        Vector3 randomDir = Random.insideUnitCircle * 20f;
        Vector3 samplePos = new Vector3(randomDir.x, 0, randomDir.y);

        // NavMesh ìœ„ì˜ ê°€ì¥ ê°€ê¹Œìš´ ìœ„ì¹˜ ì°¾ê¸°
        if (NavMesh.SamplePosition(samplePos, out NavMeshHit hit, 5.0f, NavMesh.AllAreas))
        {
            return hit.position;
        }

        return Vector3.zero;
    }

    protected override void OnDisable()
    {
        // Scenario ì¢…ë£Œ ì‹œ ëª¨ë“  Person ì‚­ì œ
        foreach (var person in m_SpawnedPersons)
        {
            if (person != null)
                Destroy(person);
        }
        m_SpawnedPersons.Clear();
    }
}
```

---

## ğŸ›ï¸ Section 3: Parameter & Sampler

### 3.1 Parameter íƒ€ì…

**íŒŒì¼ ìœ„ì¹˜**: `Runtime/Randomization/Parameters/`

#### FloatParameter (ì‹¤ìˆ˜)

```csharp
public FloatParameter lightIntensity = new FloatParameter
{
    value = new UniformSampler(0.5f, 2.0f) // ê· ë“± ë¶„í¬
};

public FloatParameter height = new FloatParameter
{
    value = new NormalSampler(1.7f, 0.1f, 1.5f, 2.0f) // ì •ê·œ ë¶„í¬ (í‰ê· , í‘œì¤€í¸ì°¨, min, max)
};

public FloatParameter fixedValue = new FloatParameter
{
    value = new ConstantSampler(1.0f) // ê³ ì • ê°’
};
```

---

#### IntParameter (ì •ìˆ˜)

```csharp
public IntParameter personCount = new IntParameter
{
    value = new UniformSampler(10, 50) // 10 ~ 50
};
```

---

#### CategoricalParameter (ì„ íƒ)

```csharp
// ë¬¸ìì—´ ì„ íƒ
public CategoricalParameter<string> weather = new CategoricalParameter<string>();
// Inspectorì—ì„œ ì„¤ì •: "Sunny", "Cloudy", "Rainy"

// í™•ë¥  ê°€ì¤‘ì¹˜ ì„¤ì •
public CategoricalParameter<string> behavior = new CategoricalParameter<string>
{
    probabilities = new[]
    {
        new { option = "Idle", probability = 0.3f },
        new { option = "Walk", probability = 0.5f },
        new { option = "Run", probability = 0.2f }
    }
};
```

---

#### ColorHsvaParameter (ìƒ‰ìƒ)

```csharp
public ColorHsvaParameter clothColor = new ColorHsvaParameter
{
    hue = new UniformSampler(0.0f, 1.0f),        // ì „ì²´ ìƒ‰ìƒ ë²”ìœ„
    saturation = new UniformSampler(0.5f, 1.0f), // ì±„ë„ 50~100%
    value = new UniformSampler(0.5f, 1.0f),      // ë°ê¸° 50~100%
    alpha = new ConstantSampler(1.0f)            // ë¶ˆíˆ¬ëª…
};
```

---

### 3.2 Sampler ì‚¬ìš©ë²•

**Sampler íƒ€ì…**:
- `ConstantSampler`: ê³ ì • ê°’
- `UniformSampler`: ê· ë“± ë¶„í¬ (min, max)
- `NormalSampler`: ì •ê·œ ë¶„í¬ (mean, stdDev, min, max)
- `AnimationCurveSampler`: Unity AnimationCurve ê¸°ë°˜

**ì˜ˆì‹œ**:
```csharp
// ê· ë“± ë¶„í¬: 0.5 ~ 2.0
FloatParameter uniformParam = new FloatParameter
{
    value = new UniformSampler(0.5f, 2.0f)
};

// ì •ê·œ ë¶„í¬: í‰ê·  1.7, í‘œì¤€í¸ì°¨ 0.1, ë²”ìœ„ 1.5 ~ 2.0
FloatParameter normalParam = new FloatParameter
{
    value = new NormalSampler(mean: 1.7f, stdDev: 0.1f, min: 1.5f, max: 2.0f)
};

// ìƒ˜í”Œë§
float value1 = uniformParam.Sample(); // 0.5 ~ 2.0 ì‚¬ì´ ëœë¤ ê°’
float value2 = normalParam.Sample();  // ì •ê·œ ë¶„í¬ ê¸°ë°˜ ê°’
```

---

## ğŸ”— Section 4: í•µì‹¬ íŒŒì¼ ì°¸ì¡°

### 4.1 Camera & Labeler

| íŒŒì¼ | ê²½ë¡œ | ìš©ë„ |
|------|------|------|
| **PerceptionCamera.cs** | `Runtime/GroundTruth/PerceptionCamera.cs` | ì¹´ë©”ë¼ ìº¡ì²˜ ì‹œìŠ¤í…œ (27KB) |
| **CameraLabeler.cs** | `Runtime/GroundTruth/Labelers/CameraLabeler.cs` | Labeler ê¸°ë³¸ í´ë˜ìŠ¤ (500ì¤„) |
| **BoundingBoxLabeler.cs** | `Runtime/GroundTruth/Labelers/BoundingBox/BoundingBoxLabeler.cs` | 2D bbox ì˜ˆì œ |
| **DatasetCapture.cs** | `Runtime/GroundTruth/DatasetCapture.cs` | ì „ì—­ ê´€ë¦¬ì (32KB) |
| **SimulationState.cs** | `Runtime/GroundTruth/SimulationState.cs` | ì‹œë®¬ë ˆì´ì…˜ ìƒíƒœ (61KB) |

---

### 4.2 Randomizer

| íŒŒì¼ | ê²½ë¡œ | ìš©ë„ |
|------|------|------|
| **Randomizer.cs** | `Runtime/Randomization/Randomizers/Randomizer.cs` | Randomizer ê¸°ë³¸ í´ë˜ìŠ¤ |
| **ScenarioBase.cs** | `Runtime/Randomization/Scenarios/ScenarioBase.cs` | Scenario ê¸°ë³¸ í´ë˜ìŠ¤ |
| **RandomizerTagManager.cs** | `Runtime/Randomization/Randomizers/RandomizerTagManager.cs` | Tag ì¿¼ë¦¬ ì‹œìŠ¤í…œ |
| **LightRandomizer.cs** | `Runtime/Randomization/RandomizerLibrary/LightRandomizer.cs` | ì¡°ëª… ëœë¤í™” ì˜ˆì œ |
| **MaterialRandomizer.cs** | `Runtime/Randomization/RandomizerLibrary/MaterialRandomizer.cs` | ì¬ì§ˆ ëœë¤í™” ì˜ˆì œ |

---

### 4.3 Parameter & Sampler

| íŒŒì¼ | ê²½ë¡œ | ìš©ë„ |
|------|------|------|
| **Parameter.cs** | `Runtime/Randomization/Parameters/Parameter.cs` | Parameter ê¸°ë³¸ í´ë˜ìŠ¤ |
| **NumericParameter.cs** | `Runtime/Randomization/Parameters/NumericParameter.cs` | Float/Int íŒŒë¼ë¯¸í„° |
| **CategoricalParameter.cs** | `Runtime/Randomization/Parameters/CategoricalParameter.cs` | ì„ íƒ íŒŒë¼ë¯¸í„° |
| **UniformSampler.cs** | `Runtime/Randomization/Samplers/SamplerTypes/UniformSampler.cs` | ê· ë“± ë¶„í¬ |
| **NormalSampler.cs** | `Runtime/Randomization/Samplers/SamplerTypes/NormalSampler.cs` | ì •ê·œ ë¶„í¬ |

---

### 4.4 Output & Serialization

| íŒŒì¼ | ê²½ë¡œ | ìš©ë„ |
|------|------|------|
| **IConsumerEndpoint.cs** | `Runtime/GroundTruth/Consumers/IConsumerEndpoint.cs` | ì¶œë ¥ ì¸í„°í˜ì´ìŠ¤ |
| **SoloEndpoint.cs** | `Runtime/GroundTruth/Consumers/Solo/SoloEndpoint.cs` | SOLO JSON ì¶œë ¥ |
| **Frame.cs** | `Runtime/GroundTruth/DataModel/Frame.cs` | í”„ë ˆì„ ë°ì´í„° ëª¨ë¸ |
| **Annotation.cs** | `Runtime/GroundTruth/DataModel/Annotation.cs` | Annotation ë°ì´í„° ëª¨ë¸ |

---

### 4.5 Sensor

| íŒŒì¼ | ê²½ë¡œ | ìš©ë„ |
|------|------|------|
| **CameraSensor.cs** | `Runtime/GroundTruth/Sensors/CameraSensor.cs` | Sensor ê¸°ë³¸ í´ë˜ìŠ¤ |
| **UnityCameraSensor.cs** | `Runtime/GroundTruth/Sensors/SensorTypes/UnityCameraSensor.cs` | í‘œì¤€ ì¹´ë©”ë¼ |
| **CircularFisheyeCameraSensor.cs** | `Runtime/GroundTruth/Sensors/SensorTypes/CircularFisheyeCameraSensor.cs` | ì–´ì•ˆ ë Œì¦ˆ |

---

## ğŸ¯ Section 5: ê°œë°œ íŒ¨í„´ ë° Best Practice

### 5.1 Labeler ê°œë°œ ì²´í¬ë¦¬ìŠ¤íŠ¸

**ê¸°ë³¸ êµ¬í˜„**:
- [ ] `description`, `labelerId` êµ¬í˜„
- [ ] `supportsVisualization` ì„¤ì •
- [ ] `Setup()`: AnnotationDefinition ë“±ë¡
- [ ] `OnUpdate()`: Annotation ìƒì„± ë° ë³´ê³ 
- [ ] `Cleanup()`: ë¦¬ì†ŒìŠ¤ ì •ë¦¬

**Performance**:
- [ ] ë§¤ í”„ë ˆì„ ì‹¤í–‰ë˜ë¯€ë¡œ ì„±ëŠ¥ ìµœì í™” í•„ìˆ˜
- [ ] ë¬´ê±°ìš´ ì‘ì—…ì€ AsyncFuture ì‚¬ìš©
- [ ] GameObject.Find() ëŒ€ì‹  Tag ë˜ëŠ” ìºì‹±

**Annotation ë³´ê³ **:
```csharp
// ë™ê¸°ì‹
sensorHandle.ReportAnnotation(m_AnnotationDefinition, annotationData);

// ë¹„ë™ê¸°ì‹ (Phase 2)
sensorHandle.ReportAnnotationAsync(m_AnnotationDefinition, asyncFuture);
```

---

### 5.2 Randomizer ê°œë°œ ì²´í¬ë¦¬ìŠ¤íŠ¸

**ê¸°ë³¸ êµ¬í˜„**:
- [ ] `OnCreate()`: ì´ˆê¸°í™”
- [ ] `OnIterationStart()`: ë§¤ Iteration ì‹¤í–‰
- [ ] Parameter ì •ì˜ (public í•„ë“œë¡œ Inspector ë…¸ì¶œ)
- [ ] TagManager.Query() ì‚¬ìš©

**Tag ê¸°ë°˜ ì¿¼ë¦¬**:
```csharp
// Tag ì •ì˜
public class MyObjectTag : RandomizerTag { }

// Randomizerì—ì„œ ì¿¼ë¦¬
foreach (var obj in tagManager.Query<MyObjectTag>()) {
    // obj ë³€ê²½
}
```

**Reproducibility**:
- [ ] Random.InitState() ëŒ€ì‹  Sampler ì‚¬ìš©
- [ ] Scenarioì˜ randomSeed í™œìš©

---

### 5.3 Multi-Camera ë™ê¸°í™” (Phase 2 ëª©í‘œ)

**ë¬¸ì œ**: 6ëŒ€ ì¹´ë©”ë¼ê°€ ë™ì‹œì— ê°™ì€ í”„ë ˆì„ ìº¡ì²˜í•´ì•¼ í•¨

**í•´ê²°ì±…**:
```csharp
public class MultiCameraSync : MonoBehaviour
{
    public PerceptionCamera[] cameras;

    void Update()
    {
        // ëª¨ë“  ì¹´ë©”ë¼ê°€ ê°™ì€ í”„ë ˆì„ ë²ˆí˜¸ ì‚¬ìš©
        int currentFrame = DatasetCapture.currentFrame;

        foreach (var cam in cameras)
        {
            // ìˆ˜ë™ ìº¡ì²˜ íŠ¸ë¦¬ê±°
            cam.RequestCapture();
        }
    }
}
```

---

### 5.4 SOLO â†’ YOLO ë³€í™˜ (Phase 1)

**í›„ì²˜ë¦¬ ìŠ¤í¬ë¦½íŠ¸** (Python):
```python
import json

# SOLO JSON ì½ê¸°
with open('captures_000.json', 'r') as f:
    solo_data = json.load(f)

# YOLO txt ìƒì„±
for frame in solo_data['frames']:
    frame_id = frame['frame']
    annotations = frame['annotations']

    yolo_lines = []
    for ann in annotations:
        if ann['id'] == 'bounding_box_2d':
            for bbox in ann['values']:
                # SOLO bbox: {x, y, width, height}
                # YOLO bbox: class x_center y_center width height (normalized)
                class_id = bbox['labelId']
                x_center = (bbox['x'] + bbox['width'] / 2) / 1920
                y_center = (bbox['y'] + bbox['height'] / 2) / 1080
                width_norm = bbox['width'] / 1920
                height_norm = bbox['height'] / 1080

                yolo_lines.append(f"{class_id} {x_center} {y_center} {width_norm} {height_norm}")

    # YOLO txt ì €ì¥
    with open(f'frame_{frame_id:06d}.txt', 'w') as f:
        f.write('\n'.join(yolo_lines))
```

---

## ğŸ“– ë‹¤ìŒ ë‹¨ê³„

### íŒŒì¼ êµ¬ì¡° ë³´ê¸°
**[reference/ë””ë ‰í† ë¦¬_êµ¬ì¡°.txt â†’](reference/ë””ë ‰í† ë¦¬_êµ¬ì¡°.txt)**
- 100+ íŒŒì¼ ì „ì²´ ë§µ
- ì¤‘ìš” íŒŒì¼ ìœ„ì¹˜

### ì ˆëŒ€ ê²½ë¡œ ì°¸ì¡°
**[reference/íŒŒì¼_ê²½ë¡œ.txt â†’](reference/íŒŒì¼_ê²½ë¡œ.txt)**
- Copy-paste ê°€ëŠ¥í•œ ì ˆëŒ€ ê²½ë¡œ

### í”„ë¡œì íŠ¸ ì‹œì‘
**[../../README.md â†’](../../README.md)**
- í”„ë¡œì íŠ¸ ê°œìš”
- Phaseë³„ ëª©í‘œ

---

## ğŸ¯ í•µì‹¬ ìš”ì•½

1. **Labeler ê°œë°œ**: CameraLabeler ìƒì† â†’ Setup â†’ OnUpdate â†’ ReportAnnotation
2. **Randomizer ê°œë°œ**: Randomizer ìƒì† â†’ Parameter ì •ì˜ â†’ OnIterationStart â†’ TagManager.Query
3. **Parameter ì‚¬ìš©**: FloatParameter, CategoricalParameter + UniformSampler, NormalSampler
4. **Tag ê¸°ë°˜ ì¿¼ë¦¬**: GameObject.Find() ëŒ€ì‹  RandomizerTag + Query()
5. **AsyncFuture**: GPU ì‘ì—… ë¹„ë™ê¸° ì²˜ë¦¬ (Phase 2 ëª©í‘œ)

**ë‹¤ìŒ ì½ê¸°**: [reference/ë””ë ‰í† ë¦¬_êµ¬ì¡°.txt](reference/ë””ë ‰í† ë¦¬_êµ¬ì¡°.txt) â†’
